// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: bookings.sql

package sqlc

import (
	"context"
	"database/sql"
)

const cancelBooking = `-- name: CancelBooking :execresult
UPDATE bookings 
SET status = 'CANCELLED'
WHERE id = ?1 
  AND user_id = ?2
  AND status IN ('CREATED', 'PAYMENT_INITIATED')
`

type CancelBookingParams struct {
	BookingID int64
	UserID    int64
}

func (q *Queries) CancelBooking(ctx context.Context, arg CancelBookingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, cancelBooking, arg.BookingID, arg.UserID)
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (user_id, event_id, status)
VALUES (?1, ?2, 'CREATED')
RETURNING id
`

type CreateBookingParams struct {
	UserID  int64
	EventID int64
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createBooking, arg.UserID, arg.EventID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteBookingSeat = `-- name: DeleteBookingSeat :execrows
;

delete from booking_seats 
where seat_id = ?1
  and user_id = ?2
`

type DeleteBookingSeatParams struct {
	SeatID int64
	UserID int64
}

func (q *Queries) DeleteBookingSeat(ctx context.Context, arg DeleteBookingSeatParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBookingSeat, arg.SeatID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteBookingSeats = `-- name: DeleteBookingSeats :execrows
;

delete from booking_seats 
where booking_id = ?1
`

func (q *Queries) DeleteBookingSeats(ctx context.Context, bookingID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBookingSeats, bookingID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBooking = `-- name: GetBooking :one
;

select id, user_id, event_id, status from bookings 
where id = ?1
`

func (q *Queries) GetBooking(ctx context.Context, bookingID int64) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getBooking, bookingID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventID,
		&i.Status,
	)
	return i, err
}

const getBookingByPaymentOrderID = `-- name: GetBookingByPaymentOrderID :one
;

SELECT b.id, b.user_id, b.event_id, b.status FROM bookings b
JOIN booking_payments bp ON b.id = bp.booking_id
WHERE bp.order_id = ?1
`

func (q *Queries) GetBookingByPaymentOrderID(ctx context.Context, orderID string) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getBookingByPaymentOrderID, orderID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventID,
		&i.Status,
	)
	return i, err
}

const getBookingSeats = `-- name: GetBookingSeats :many
;

select seat_id from booking_seats
where booking_id = ?1
`

func (q *Queries) GetBookingSeats(ctx context.Context, bookingID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getBookingSeats, bookingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var seat_id int64
		if err := rows.Scan(&seat_id); err != nil {
			return nil, err
		}
		items = append(items, seat_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookings = `-- name: GetBookings :many
select
  b.id,
  b.event_id,
  CASE 
    WHEN COUNT(bs.seat_id) = 0 THEN cast(json_array() as text)
    ELSE cast(
      json_group_array(json_object('id', bs.seat_id))
      as text
    )
  END AS seats
from bookings b
left join booking_seats as bs on bs.booking_id = b.id
where 1=1
  and ?1 = b.user_id
group by b.id, b.event_id
`

type GetBookingsRow struct {
	ID      int64
	EventID int64
	Seats   string
}

func (q *Queries) GetBookings(ctx context.Context, userID int64) ([]GetBookingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsRow
	for rows.Next() {
		var i GetBookingsRow
		if err := rows.Scan(&i.ID, &i.EventID, &i.Seats); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBookingOrder = `-- name: InsertBookingOrder :exec
;

INSERT INTO booking_orders (booking_id, order_id, status)
VALUES (?1, ?2, ?3)
`

type InsertBookingOrderParams struct {
	BookingID int64
	OrderID   string
	Status    *string
}

func (q *Queries) InsertBookingOrder(ctx context.Context, arg InsertBookingOrderParams) error {
	_, err := q.db.ExecContext(ctx, insertBookingOrder, arg.BookingID, arg.OrderID, arg.Status)
	return err
}

const insertBookingSeat = `-- name: InsertBookingSeat :exec
insert into booking_seats (user_id, booking_id, seat_id)
values (?1, ?2, ?3)
`

type InsertBookingSeatParams struct {
	UserID    int64
	BookingID int64
	SeatID    int64
}

func (q *Queries) InsertBookingSeat(ctx context.Context, arg InsertBookingSeatParams) error {
	_, err := q.db.ExecContext(ctx, insertBookingSeat, arg.UserID, arg.BookingID, arg.SeatID)
	return err
}

const updateBookingOrderStatus = `-- name: UpdateBookingOrderStatus :exec
;

UPDATE booking_orders 
SET status = ?1
WHERE booking_id = ?2
`

type UpdateBookingOrderStatusParams struct {
	Status    *string
	BookingID int64
}

func (q *Queries) UpdateBookingOrderStatus(ctx context.Context, arg UpdateBookingOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingOrderStatus, arg.Status, arg.BookingID)
	return err
}

const updateBookingPaymentStatus = `-- name: UpdateBookingPaymentStatus :exec
;

UPDATE booking_payments 
SET status = ?1
WHERE order_id = ?2
`

type UpdateBookingPaymentStatusParams struct {
	Status  *string
	OrderID string
}

func (q *Queries) UpdateBookingPaymentStatus(ctx context.Context, arg UpdateBookingPaymentStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingPaymentStatus, arg.Status, arg.OrderID)
	return err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :exec
;

UPDATE bookings 
SET status = ?1
WHERE id = ?2
`

type UpdateBookingStatusParams struct {
	Status    string
	BookingID int64
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingStatus, arg.Status, arg.BookingID)
	return err
}
